#### 对等层通信的概念
为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式成为对等层通信。
在这一过程中，每一层的协议在对等层之间交换信息，该信息称为协议数据单元（PDU）。位于源计算机的每个通信层，使用针对该层的PDU同目的计算机的对等层进行通信。

不同层的PDU中包含有不同的信息，因此PDU在不同层被赋予了不同的名称。

如上层数据在传输层添加TCP报头后得到的PDU被称为Segment（数据段）                                    
数据段被传递给网络层，网络层添加IP报头得到的PDU被称为Packet（数据包）                                     
数据包被传递到数据链路层，封装数据链路层报头得到的PDU被称为Frame（数据帧）                                    
最后，帧被转换为比特(物理层)

#### 数据链路层
数据链路层的数据帧结构有两种，分别是Ethernet_II帧和IEEE802.3帧

Ethernet_II帧

![Ethernet_II帧结构](https://github.com/JustBasicOperation/take-down/blob/master/images/Ethernet_II%E5%B8%A7%E6%A0%BC%E5%BC%8F.png)

以太网数据帧的长度在64-1518字节之间
* DMAC（Destination MAC）是目的MAC地址。DMAC字段长度为6个字节，标识帧的接收者。

* SMAC（Source MAC）是源MAC地址。SMAC字段长度为6个字节，标识帧的发送者。

* 类型字段（Type）用于标识数据字段中包含的高层协议，该字段长度为2个字节。类型字段取值为0x0800的帧代表IP协议帧；类型字段取值为0806的帧代表ARP协议帧。

* 数据字段(Data)是网络层数据，最小长度必须为46字节以保证帧长至少为64字节，数据字段的最大长度为1500字节。

* 循环冗余校验字段（FCS）提供了一种错误检测机制。该字段长度为4个字节。


IEEE802.3帧

![IEEE802.3帧结构](https://github.com/JustBasicOperation/take-down/blob/master/images/IEEE802.3%E5%B8%A7%E6%A0%BC%E5%BC%8F.png)

IEEE 802.3帧格式类似于Ethernet_II帧，只是Ethernet_II帧的Type域被802.3帧的Length域取代，并且占用了Data字段的8个字节作为LLC和SNAP字段。
Length字段定义了Data字段包含的字节数

#### 网络层

![IP报文格式](https://github.com/JustBasicOperation/take-down/blob/master/images/IP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.png)

* 版本：IP协议的版本，目前的IP协议版本号为4，下一代IP协议版本号为6。 

* 首部长度：IP报头的长度。固定部分的长度（20字节）和可变部分的长度之和。共占4位。最大为1111，即10进制的15，代表IP报头的最大长度可以为15个32bits（4字节），也就是最长可为15*4=60字节，除去固定部分的长度20字节，可变部分的长度最大为40字节。

* 服务类型：Type Of Service。

* 总长度：IP报文的总长度。报头的长度和数据部分的长度之和。

* 标识：唯一的标识主机发送的每一分数据报。通常每发送一个报文，它的值加一。当IP报文长度超过传输网络的MTU（最大传输单元）时必须分片，这个标识字段的值被复制到所有数据分片的标识字段中，使得这些分片在达到最终目的地时可以依照标识字段的内容重新组成原先的数据。

* 标志：共3位。R、DF、MF三位。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。

* 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8）

* 生存时间：IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为0时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定，当前值为 64。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。

* 协议：指出IP报文携带的数据使用的是那种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程（不同的协议有专门不同的进程处理）。和端口号类似，此处采用协议号，TCP的协议号为6，UDP的协议号为17。ICMP的协议号为1，IGMP的协议号为2.

* 首部校验和：计算IP头部的校验和，检查IP报头的完整性。

* 源IP地址：标识IP数据报的源端设备。

* 目的IP地址：标识IP数据报的目的地址。

#### 传输层
TCP(Transmission Control Protocol) 即传输控制协议，是一种面向连接的(需通过三次握手来建立 TCP 连接，在主机间建立会话)、可靠的(TCP 通过确认和按顺序传递来确保数据的传递)、基于字节流的传输层通信协议。

但 TCP 传输比较慢，开销略高，并且只支持点对点通信。
当应用层向 TCP 层发送用于网间传输的 8 字节表示的数据流，TCP 则把数据流分割成适当长度的报文段，最大传输段大小(MSS)通常受该计算机连接的网络的数据链路层的最大传送单元(MTU)限制，之后 TCP 把数据包传给 IP 层，由它来通过网络将包传送给接收端实体的 TCP 层。

![TCP报文格式](https://github.com/JustBasicOperation/take-down/blob/master/images/TCP%E5%B8%A7%E7%BB%93%E6%9E%84.png)

* 源端口：2 个字节，是一个大于 1023 的 16 位数字，由基于 TCP 应用程序的用户进程随机选择。

* 目的端口：2 个字节，指明接收者所用的端口号，一般由应用程序来指定。

* 顺序号：4 个字节，用来标识从 TCP 源端向 TCP 目的端发送的数据字节流，它表示在这个报文段中的第一个数据字节的顺序号。
如果将字节流看作在两个应用程序间的单向流动，则 TCP 用顺序号对每个字节进行计数，序号是 32 bit 的无符号数，序号达到 2^32-1 后又从 0 开始。
比如我们收到一个数据报中 sq(顺序号) =0，数据报内容为 20 字节，那么下一个数据报的 sq 就应该是 21。
当建立一个新的连接时，SYN 标志变为 1，顺序号字段包含由这个主机选择的该连接的初始顺序号 ISN。

* 确认序号：4 个字节，包含发送确认的一端所期待收到的下一个顺序号。因此，确认序号应该是上次已经成功收到数据字节顺序号加 1 。比如我们收到的一个数据报的 sq = 0 ，数据报内容为 20 字节，那么我们的 ack(确认序号) 应该是 21 ，用来表明 sq=0 ，内容为 20 字节的数据报已经收到，接下来期望收到的是 sq=21 的数据报。只有 ACK 标志为 1 时确认序号字段才有效。

* 报文长度：4 位，给出报头中 32 bit 字的数目，需要这个值是因为任选字段的长度是可变的，这个字段占 4 bit，即 TCP 最多有 60 (15*4) 字节的首部。

* 保留区：6 位，保留给将来使用，目前必须置为 0 。

* 控制位：6位，控制位包括

* URG：为 1 表示紧急指针有效，为 0 则忽略紧急指针值。

* ACK：为 1 表示确认号有效，为 0 表示报文中不包含确认信息，忽略确认号字段。

* PSH：为 1 表示是带有 PUSH 标志的数据，表示发送端缓存中已经没有待发送的数据，指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。

* RST：用于复位由于主机崩溃或其他原因而出现错误的连接。它还可以用于拒绝非法的报文段和拒绝连接请求。一般情况下，如果收到一个 RST 为 1 的报文，那么一定发生了某些问题。

* SYN：同步序号，为 1 表示连接请求，用于建立连接和使顺序号同步。

* FIN：用于释放连接，为 1 表示发送方已经没有数据发送了，即关闭本方数据流。

* 窗口大小：2 个字节，表示从确认号开始，本报文的源方可以接收的字节数，即源方接收窗口的大小。
窗口大小是一个 16 bit 字段，因而窗口大小最大为  2^16-1 。

* 校验和：2 个字节，对整个的 TCP 报文段(包括 TCP 头部和 TCP 数据以及伪报文头)进行校验和计算。
这是一个强制性的字段，要求由发送方计算和存储，并由接收端进行验证(接收端要与发送端数值结果完全一样，才能证明数据是有效的)。

* 紧急指针：2 个字节，是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。
TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式，只有当 URG 标志置为 1 时紧急指针才有效。

* 选项：n*4 字节，常见的可选字段是最长报文大小 MSS(Maximum Segment Size)。
每个连接方通常都在通信的第一个报文段 (为建立连接而设置 SYN 标志的那个段) 中指明这个选项，它指明本端所能接收的最大长度的报文段。
选项长度不一定是 32 位字的整数倍，所以需要添加填充位，使得报文长度为 32 位字的整数倍。

* 数据：不定长度，为上层协议封装好的数据。

UDP(User Datagram Protocol) 即用户数据报协议，在网络中它与 TCP 协议一样用于处理数据包，是一种不可靠(服务不用确认、不对报文排序、不进行流量控制，可能会出现丢失、重复、失序现象)、无连接(在主机间不建立会话)的协议。

由于 UDP 传输不是可靠性服务，所以帧结构较为简单，而且处理与发送速率高，开销要求低，
支持点对点和一点对多点的通信，经常用作音频、视频和普通数据的传输协议，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。

![UDP报文格式](https://github.com/JustBasicOperation/take-down/blob/master/images/UDP%E5%B8%A7%E7%BB%93%E6%9E%84.png)

* 源端口：16 bit (2 个字节)，是一个大于 1023 的 16 位数字，由基于 UDP 应用程序的用户进程随机选择。

* 目的端口：16 bit (2 个字节)，指明接收者所用的端口号，一般由应用程序来指定。

* 数据长度：16 bit (2 个字节)，标明 UDP 头部和 UDP 数据的总字节长度。

* 校验和字段：16 bit (2 个字节)，用来对 UDP 头部和 UDP 数据进行校验。与 TCP 不同的是，此字段是可选项，而 TCP 数据段中必须包含校验和字段。

* 数据：不定长度，为上层协议封装好的数据。

最后，通过一张图片进行总结，方便理解记忆：

![网络各层PDU格式](https://github.com/JustBasicOperation/take-down/blob/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82PDU.png)

ps:

对于TCP协议而言，是流式传输协议，所以理论上一次传输可以发送无限大的数据，但是取决于MSS的设定(默认536B)。对于UDP而言则是分片发送，一次传输最多可以发送65535B的数据
(和UDP报文中的索引所占大小为2B有关，2^16 - 1 = 65535)，当TCP或者UDP包文长度超过IP报文长度限制(1500B)，IP层会在发送时进行分片，接收端则需要重新进行组包，这时有可能发生组包错误。
对于TCP传输发送组包错误时，有差错重传机制，对于UDP传输而言则会直接丢弃该包。

